<?xml version="1.0"?><st-source><!-- Name: Archive FilesComment: This parcel adds support for viewing and extracting contents of archive files (like zip, gz, ...) using the File Browser.HideSource: falseParcel: #('ArchiveFiles')PrerequisiteParcels: #(#('URISupport' '7') #('Zlib Interface' '2.0'))SaveSource: truePost-Load Block: 	[:package | Tools.FileTools.FileBrowser new open]Date: 4:44:35 am June 1, 2003 --><time-stamp>From VisualWorksÂ® NonCommercial, Release 7 of June 14, 2002 on June 1, 2003 at 4:44:35 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ArchiveExtractDialog</name><environment>Tools.FileTools</environment><super>UI.SimpleDialog</super><private>true</private><indexed-type>none</indexed-type><inst-vars>whichFiles boxUseFolderNames boxSkipOlderFiles filesSpecification boxOverwriteExisting extractDestDir someFileSelected directoryTree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category></class><comment><class-id>Tools.FileTools.ArchiveExtractDialog</class-id><body>ArchiveExtractDialog is a class representing a simple dialog used to ask the user about the details of file extraction (see ArchiveFileViewer).</body></comment><class><name>ArchiveFilename</name><environment>Tools.FileTools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>archiveName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Archive Files</category></class><comment><class-id>Tools.FileTools.ArchiveFilename</class-id><body>ArchiveFilename is a class representing an archive file (zip, tar, gz, ...) in the same way the Filename class represents a generic file/directory.Its subclasses represent the various specific archive formats.The subclasses must implement the following methods:	(Initialize-release) initialize:	...	initialize itself for the given archive file (OR, instead of implementing initialize: you may reimplement class method from:)	(Class/testing) isAble:	...	is this class able to handle the given file?	(Instance/contents) filenames	...	collection of the filenames in the archive	(Instance/contents) containedFiles	...	collection of the archive contents (see comment in the method)	(Instance/contents) contentsInformation	...	list of the archive contents (see comment in the method)You should (but not have to) implement also the isAble:having: method, which provides the same test as isAble: does, but using the given file header instead of reading it yourself.</body></comment><class><name>ArchiveFile</name><environment>Tools.FileTools</environment><super>Tools.FileTools.DirectoryItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>overwriteAll cancelExtraction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Archive Files</category></class><comment><class-id>Tools.FileTools.ArchiveFile</class-id><body>I represent an archive file (zip, tar, gz, ...), I can report the files I contain.</body></comment><class><name>ZipArchiveFilename</name><environment>Tools.FileTools</environment><super>Tools.FileTools.ArchiveFilename</super><private>false</private><indexed-type>none</indexed-type><inst-vars>zipDirectory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Archive Files</category></class><comment><class-id>Tools.FileTools.ZipArchiveFilename</class-id><body>ZipArchiveFilename is a concrete subclass of ArchiveFilename that is able to handle standard zip archives.</body></comment><class><name>UnRARInterface</name><environment>Smalltalk</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			UnRARInterfaceDictionary.*			</imports><category>Archive Files</category><attributes><includeFiles><item>unrar_vw.h</item></includeFiles><includeDirectories><item>c:\dokumenty\petr\skola\obp\unrar\</item></includeDirectories><libraryFiles><item>unrar.dll </item></libraryFiles><libraryDirectories><item>c:\windows\system</item></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel></attributes></class><comment><class-id>UnRARInterface</class-id><body>This is a DLL and C Connect interface to the UnRAR library.</body></comment><class><name>GZipArchiveFilename</name><environment>Tools.FileTools</environment><super>Tools.FileTools.ArchiveFilename</super><private>false</private><indexed-type>none</indexed-type><inst-vars>compressionMethod flags time extraFlags operatingSystem extraField origFilename fileComment crc16 crc32 uncompressedSize compressedSize dataStartOffset </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Archive Files</category></class><comment><class-id>Tools.FileTools.GZipArchiveFilename</class-id><body>This is a concrete implementation of ArchiveFilename designed to work with files in gzip format (.gz). The gzip file contains a single compressed file (i.e. it is not a traditional archive). Therefore, the data for the contained file are included directly in this class:Instance Variables:	compressedSize	Integer	Size of the compressed data	compressionMethod	Integer Method used for compression of the file. 8 = deflate is the only currently supported method.	crc16	Integer	16-bit CRC of the file data (uncompressed)	crc32	Integer	32-bit CRC of the file data (uncompressed)	dataStartOffset	Integer	Offset of the compressed file data from the start of the file.	extraField	String	Extra field data	extraFlags	Integer	Extra flags	fileComment	String	File comment	flags	Integer	Basic gzip file flags	operatingSystem	Integer	OS on which the compression took place	origFilename	String	Original name of the compressed file	time	Integer	Modification time of the compressed file (Unix format)	uncompressedSize	Integer	Size of the original, uncompressed fileSee the gzip specification for details on the items.</body></comment><class><name>ArchiveFileViewer</name><environment>Tools.FileTools</environment><super>Tools.FileTools.FileViewer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>getContentsTable archiveFile getSelectedFile </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category></class><comment><class-id>Tools.FileTools.ArchiveFileViewer</class-id><body>ArchiveFileViewer, a descendant to FileViewer, is intended to display the contents of an archive file (zip, tar, gz, ...).</body></comment><class><name>ArchiveContainedFile</name><environment>Tools.FileTools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename date uncompressedSize ratio compressedSize path rawDate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Archive Files</category></class><comment><class-id>Tools.FileTools.ArchiveContainedFile</class-id><body>This is a storage class for a single file contained within an archive.Instance Variables:	compressedSize	&lt;Number&gt;	compressed size (bytes)	date	&lt;String&gt;	modification date/time (already in string representation)	filename	&lt;String&gt;	filename without the path within the archive	path	&lt;String&gt;	path within the archive	ratio	&lt;String&gt;	compression ratio, represented as a string in form "46 %"	rawDate	&lt;TimeStamp&gt;	modification date/time (as a TimeStamp)	uncompressedSize	&lt;Number&gt;	original, uncompressed size (bytes)</body></comment><class><name>RarArchiveContainedFile</name><environment>Tools.FileTools</environment><super>Tools.FileTools.ArchiveContainedFile</super><private>false</private><indexed-type>none</indexed-type><inst-vars>operatingSystem fileCRC unpackVersion packingMethod fileAttr </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Archive Files</category></class><comment><class-id>Tools.FileTools.RarArchiveContainedFile</class-id><body>This is a subclass of ArchiveContainedFile that adds more details available for files contained within a RAR archive.Instance Variables:	fileAttr	Integer	File attributes	fileCRC	Integer	32-bit CRC of the original (uncompressed) file data	operatingSystem	Integer	OS used for archiving	packingMethod	Integer	Packing method	unpackVersion	Integer	RAR Version required to unpack the file</body></comment><class><name>RarArchiveFilename</name><environment>Tools.FileTools</environment><super>Tools.FileTools.ArchiveFilename</super><private>false</private><indexed-type>none</indexed-type><inst-vars>archiveFlags archiveHeaderSize archiveComment containedFiles </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Archive Files</category></class><comment><class-id>Tools.FileTools.RarArchiveFilename</class-id><body>This is a concrete subclass of the ArchiveFilename that is able to process RAR archives.Instance Variables:	archiveComment	String	Archive-wide comment	archiveFlags	Integer	Archive flags	archiveHeaderSize	Integer	Size of the archive header	containedFiles	Collection of: RarArchiveContainedFile	Files contained in the archive</body></comment><methods><class-id>Tools.FileTools.ArchiveExtractDialog</class-id> <category>aspects</category><body>boxOverwriteExisting	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^boxOverwriteExisting isNil		ifTrue:			[boxOverwriteExisting := false asValue]		ifFalse:			[boxOverwriteExisting]</body><body>boxSkipOlderFiles	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^boxSkipOlderFiles isNil		ifTrue:			[boxSkipOlderFiles := false asValue]		ifFalse:			[boxSkipOlderFiles]</body><body>boxUseFolderNames	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^boxUseFolderNames isNil		ifTrue:			[boxUseFolderNames := false asValue]		ifFalse:			[boxUseFolderNames]</body><body>directoryTree	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^directoryTree isNil		ifTrue:			[directoryTree := SelectionInTree new]		ifFalse:			[directoryTree]</body><body>extractDestDir	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^extractDestDir isNil		ifTrue:			[extractDestDir := String new asValue]		ifFalse:			[extractDestDir]</body><body>filesSpecification	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^filesSpecification isNil		ifTrue:			[filesSpecification := String new asValue]		ifFalse:			[filesSpecification]</body><body>whichFiles	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^whichFiles isNil		ifTrue:			[whichFiles := nil asValue]		ifFalse:			[whichFiles]</body></methods><methods><class-id>Tools.FileTools.ArchiveExtractDialog</class-id> <category>initialize-release</category><body>initialize	super initialize.	someFileSelected := false.	self whichFiles value: #allFiles.	boxUseFolderNames := true asValue.	filesSpecification := '*.*' asValue.	self directoryTree selectionIndexHolder onChangeSend: #directorySelected		to: self.	self reloadDirectories</body><body>postBuildWith: aBuilder 	super postBuildWith: aBuilder.	self someFileSelected: someFileSelected</body></methods><methods><class-id>Tools.FileTools.ArchiveExtractDialog</class-id> <category>UI</category><body>someFileSelected: hasBeenSelected 	"Should this dialog assume that some file has been selected? I.e. should it allow to use the 'Selected file' button?"	| rad |	someFileSelected := hasBeenSelected.	rad := builder componentAt: #radOnlySelected.	rad ifNotNil: 			[rad widget isEnabled: hasBeenSelected.			hasBeenSelected 				ifTrue: [self whichFiles value: #onlySelected]				ifFalse: [self whichFiles value: #allFiles]]</body></methods><methods><class-id>Tools.FileTools.ArchiveExtractDialog</class-id> <category>directory tree</category><body>expandToDirectory: directoryFilename	| target path treeModel lastExpanded |	target := DirectoryItem on: directoryFilename.	path := target parentDirectories.	treeModel := self directoryTree list.	lastExpanded := nil.	Cursor wait showWhile:		[path do: [:each |			| index |			index := treeModel indexOf: each.			index = 0 ifTrue: [^lastExpanded].			treeModel expand: index.			lastExpanded := each]].	^target</body><body>reloadDirectories	self directoryTree 		list: (TreeModel on: TopLevelItem current displayRoot: false)</body><body>updateSelectedDirectory	self extractDestDir value: self directoryTree selection</body></methods><methods><class-id>Tools.FileTools.ArchiveExtractDialog</class-id> <category>notifications</category><body>directorySelected	self updateSelectedDirectory</body><body>radFilesSpecifiedChanged	"The 'Files' radiobutton within 'Files' group has been (de)selected."	| edit selection |	edit := builder componentAt: #editFilesSpec.	selection := self whichFiles value.	edit ifNotNil: [edit widget isEnabled: selection = #filesSpecified]</body></methods><methods><class-id>Tools.FileTools.ArchiveExtractDialog</class-id> <category>actions</category><body>setFolderFromEdit	self expandToDirectory: extractDestDir value asFilename.	self directoryTree selection: extractDestDir value</body></methods><methods><class-id>Tools.FileTools.ArchiveFilename</class-id> <category>visuals</category><body>icon	^self class genericArchiveIcon</body></methods><methods><class-id>Tools.FileTools.ArchiveFilename</class-id> <category>initialize-release</category><body>initialize: aFilename 	archiveName := aFilename asString</body></methods><methods><class-id>Tools.FileTools.ArchiveFilename</class-id> <category>printing</category><body>printOn: aStream 	"Append to the argument aStream a sequence of characters that identifies the receiver."	"Amplifies method in superclass to add name string."	super printOn: aStream.	aStream nextPut: $(.	aStream print: self asString.	aStream nextPut: $)</body></methods><methods><class-id>Tools.FileTools.ArchiveFilename</class-id> <category>comparing</category><body>= aFilename 	"Answer whether the receiver is equal to the argument"	^self species = aFilename species and: 			[aFilename class isCaseSensitive 				ifTrue: [self asString = aFilename asString]				ifFalse: [self asString sameAs: aFilename asString]]</body><body>hash 	^self asString asUppercase hash</body></methods><methods><class-id>Tools.FileTools.ArchiveFilename</class-id> <category>converting</category><body>asFilename	"Answer a generic Filename of the underlying archive file"	^archiveName asFilename</body><body>asString	"Answer the OS-specific name string."	^archiveName</body><body>asURI	^Net.FileURL fromFilename: self asFilename</body></methods><methods><class-id>Tools.FileTools.ArchiveFilename</class-id> <category>contents</category><body>containedFiles	"Construct a List containing information on every file stored within the archive. The List contains an instance of ArchiveContainedFile for every file in the archive."	^self subclassResponsibility</body><body>contentsInformation	"Construct a TwoDList containing information on every file stored within the archive.	The list has a row for each file and the following columns: Filename, modification date/time, original size, compression ratio, compressed size, and path within the archive."	"OBSOLETE!"	^self subclassResponsibility</body><body>filenames	"Return a collection of the names of the files stored in the archive."	^self subclassResponsibility</body></methods><methods><class-id>Tools.FileTools.ArchiveFilename</class-id> <category>utilities</category><body>computeRatio: compressedSize and: uncompressedSize 	"A utility function to compute the compression ratio from the specified values."	^((uncompressedSize == 0 		ifTrue: [0]		ifFalse: [(100 - (100 * compressedSize / uncompressedSize)) rounded]) 			max: 0) printString 		, '%'</body></methods><methods><class-id>Tools.FileTools.ArchiveFilename</class-id> <category>actions</category><body>extractFile: anIndex toFile: aDestFilename 	"Extract file at the index anIndex (within the containedFiles collection) into the file specified with aDestFilename. That file is overwritten."	^self subclassResponsibility</body><body>inspectFileItem: itemNumber 	"Inspect the file item corresponding to the given number."	"As a default in this superclass, the corresponding ArchiveContainedFile will be inspected."	(self containedFiles at: itemNumber) inspect</body></methods><methods><class-id>Tools.FileTools.ArchiveFilename class</class-id> <category>instance creation</category><body>from: aFilename 	"Create the ArchiveFilename using a Filename as the name of the archive file"	| implementor |	self == ArchiveFilename 		ifTrue: 			["The behaviour of the superclass -- find the implementor and let him create itself."			implementor := self fromIfAble: aFilename.			implementor isNil ifTrue: [self unsupportedFormatError].			^implementor].	"The behaviour of the concrete classes -- create and initialize itself."	^self new initialize: aFilename</body><body>fromIfAble: aFilename 	"Create the ArchiveFilename using a Filename as the name of the archive file. If the file is 	not an archive supported by neither this nor any descendent class, return nil."	| header whichFormat |	header := self getFileHeaderFrom: aFilename.	(self isAble: aFilename havingHeader: header) 		ifTrue: [^self from: aFilename].	whichFormat := self allSubclasses 				detect: [:archiveFormat | archiveFormat isAble: aFilename havingHeader: header]				ifNone: nil.	^whichFormat isNil ifTrue: [nil] ifFalse: [whichFormat from: aFilename]</body></methods><methods><class-id>Tools.FileTools.ArchiveFilename class</class-id> <category>testing</category><body>isAble: aFilename	"Is this class able to handle the specified file?"	"ArchiveFilename does not handle anything, it is the responsibility of the subclasses."	^false</body><body>isAble: aFilename havingHeader: header 	"Is this class able to handle the specified file? header contains the header of the file, which can be used to check the file format."	"Default: I cannot use the given header, I have to check the file myself using isAble:"	^self isAble: aFilename</body><body>isAnyoneAble: aFilename 	"Am I, or any of my subclasses able to handle the specified archive file?"	| header |	^aFilename isDirectory not and: 			[header := self getFileHeaderFrom: aFilename.			(self isAble: aFilename havingHeader: header) or: 					[self allSubclasses 						anySatisfy: [:archiveFormat | archiveFormat isAble: aFilename havingHeader: header]]]</body></methods><methods><class-id>Tools.FileTools.ArchiveFilename class</class-id> <category>errors</category><body>unsupportedFormatError	self error: #errArchiveFormatNotSupported &lt;&lt; #dialogs 				&gt;&gt; ' The file is either not an archive, or its format is not supported, or it is damaged.'</body></methods><methods><class-id>Tools.FileTools.ArchiveFilename class</class-id> <category>private</category><body>getFileHeaderFrom: aFilename 	"Read the file header (first 'self maximumHeaderSize' bytes) from the given file."	| stream |	stream := (aFilename withEncoding: #binary) readStream.	^[stream nextAvailable: self maximumHeaderSize] ensure: [stream close]</body><body>maximumHeaderSize	"Size of the buffer used to test whether the file has a supported archive format. See getFileHeaderFrom, isAnyoneAble"	^8192</body></methods><methods><class-id>Tools.FileTools.ArchiveFilename class</class-id> <category>utilities</category><body>computeRatio: compressedSize and: uncompressedSize 	"A utility function to compute the compression ratio from the specified values."	^((uncompressedSize == 0 		ifTrue: [0]		ifFalse: [(100 - (100 * compressedSize / uncompressedSize)) rounded]) 			max: 0) printString 		, '%'</body><body>forceDirectoryExists: aDirName 	"Force that the directory with the given name exists, i.e. if it exists, OK. Otherwise create the directory, possibly with all the nonexistent directories on its path from the root up. The directory name must be given as absolute path."	| sep mkdir |	sep := String with: Filename separator.	mkdir := 			[:dirname | 			| fname |			fname := dirname asFilename.			(fname exists and: [fname isDirectory]) ifFalse: [fname makeDirectory]].	(Filename components: aDirName) inject: ''		into: 			[:currPath :dir | 			| nextval |			nextval := currPath.			(currPath size &gt; 0 and: [currPath last ~= Filename separator]) 				ifTrue: [nextval := nextval , sep].			nextval := nextval , dir.			mkdir value: nextval.			nextval]</body></methods><methods><class-id>Tools.FileTools.ArchiveFile</class-id> <category>initialize - release</category><body>initialize: aPlatformFilename 	filename := ArchiveFilename fromIfAble: aPlatformFilename.	filename isNil ifTrue: [ArchiveFilename unsupportedFormatError]</body></methods><methods><class-id>Tools.FileTools.ArchiveFile</class-id> <category>visuals</category><body>icon	^filename icon</body></methods><methods><class-id>Tools.FileTools.ArchiveFile</class-id> <category>contents</category><body>containedFiles	"Construct a List containing information on every file stored within the archive. The List contains an instance of ArchiveContainedFile for every file in the archive."	^filename containedFiles</body><body>contentsInformation	"Construct a TwoDList containing information on every file stored within the archive.	The list has a row for each file and the following columns: Filename, modification date/time, original size, compression ratio, compressed size, and path within the archive."	"OBSOLETE!"	^filename contentsInformation</body></methods><methods><class-id>Tools.FileTools.ArchiveFile</class-id> <category>actions</category><body>extractAllFilesTo: aDestDir overwritingExisting: overwriteExisting skippingOlder: skipOlder usingFolderNames: useFolderNames 	"Extract all files from the archive to the specified destination directory (must end with path separator if desired), using the boolean settings given."	| fnames |	fnames := filename filenames.	overwriteAll := false.	(1 to: fnames size) do: 			[:index | 			| aFilename |			aFilename := fnames at: index.			self 				extractFile: aFilename				atIndex: index				to: aDestDir				overwritingExisting: overwriteExisting				skippingOlder: skipOlder				usingFolderNames: useFolderNames]</body><body>extractFile: aFilename to: aDestDir overwritingExisting: overwriteExisting skippingOlder: skipOlder usingFolderNames: useFolderNames 	"Extract file with the given filename (with full path within the archive!) to the specified destination directory (must end with path separator if desired), using the boolean settings given."	| index fnames |	fnames := filename filenames.	index := fnames findFirst: [:fname | fname = aFilename].	index = 0 ifTrue: [self error: 'File not found in the archive!'].	overwriteAll := false.	self 		extractFile: aFilename		atIndex: index		to: aDestDir		overwritingExisting: overwriteExisting		skippingOlder: skipOlder		usingFolderNames: useFolderNames</body><body>extractFilesMatching: aFilenameMask to: aDestDir overwritingExisting: overwriteExisting skippingOlder: skipOlder usingFolderNames: useFolderNames 	"Extract files matching the given mask to the specified destination directory (must end with path separator if desired), using the boolean settings given."	self error: 'TODO: extractFilesMatching not yet implemented'</body><body>inspectFileItem: itemNumber 	"Inspect the file item corresponding to the given number. (Row number from the contentsInformation."	filename inspectFileItem: itemNumber</body></methods><methods><class-id>Tools.FileTools.ArchiveFile</class-id> <category>private</category><body>constructDestFilename: aFilename atDirectory: aDestDir usingFolderNames: useFolderNames 	"Construct the name of the file into which should be aFilename extracted with the given settings. aDestDir must end with path separator if desired."	| withUnixSlashes withNormalSlashes |	withUnixSlashes := useFolderNames 				ifTrue: [aFilename]				ifFalse: [self class fileBasename: aFilename].	withNormalSlashes := withUnixSlashes replaceAll: $/				with: Filename separator.	^(aDestDir , withNormalSlashes) asFilename</body><body>extractFile: aFilename atIndex: index to: aDestDir overwritingExisting: overwriteExisting skippingOlder: skipOlder usingFolderNames: useFolderNames 	"Extract file with the given index to the specified destination directory (must end with path separator if desired), using the boolean settings given."	| destFile item |	destFile := self 				constructDestFilename: aFilename				atDirectory: aDestDir				usingFolderNames: useFolderNames.	item := filename containedFiles at: index.	(self 		shouldExtract: aFilename		withDate: item rawDate		andSize: item uncompressedSize		to: destFile		overwritingExisting: overwriteExisting		skippingOlder: skipOlder) 			ifTrue: [filename extractFile: index toFile: destFile]</body><body>shouldExtract: aFilename withDate: aTimestamp andSize: aSize to: aDestFilename overwritingExisting: overwriteExisting skippingOlder: skipOlder 	"Should we extract a file aFilename dated with aTimestamp, having size aSize bytes into aDestFilename with the given settings?"	^aDestFilename exists 		ifTrue: 			[| shouldOverwrite currentTimestamp |			currentTimestamp := (aDestFilename modificationTimestamp 						ifNil: [aDestFilename creationTimestamp]) ifNil: [Timestamp now].			shouldOverwrite := skipOlder 						ifTrue: [currentTimestamp &lt; aTimestamp]						ifFalse: [true].			shouldOverwrite 				ifTrue: 					[self 						userWantsOverwrite: aDestFilename asString						havingSize: aDestFilename fileSize						withTimestamp: currentTimestamp						overwriting: aFilename						havingSize: aSize						withTimestamp: aTimestamp]				ifFalse: [false]]		ifFalse: [true]</body><body>userWantsOverwrite: what havingSize: sizeOfWhat withTimestamp: timeOfWhat overwriting: withWhat havingSize: sizeOfWithWhat withTimestamp: timeOfWithWhat 	"Prompt the user if he/she wants to overwrite file what, sizeOfWhat bytes, modified at timeOfWhat with file withWhat, sizeOfWithWhat bytes, modified at timeOfWithWhat. Return true/false."	| response |	overwriteAll ifTrue: [^true].	response := SimpleDialog new 				choose: 'Replace file: ' , what , (String with: Character cr) 						, (String with: Character tab) , sizeOfWhat printString 						, ' bytes, ' , (Locale current printAsTime: timeOfWhat policyNamed: #short) 						, (String with: Character cr) , 'With file: ' 						, withWhat , (String with: Character cr) 						, (String with: Character tab) , sizeOfWithWhat printString 						, ' bytes, ' 							, (Locale current printAsTime: timeOfWithWhat policyNamed: #short)				labels: #('Yes' 'Yes to All' 'No' 'Cancel')				values: #(#yes #all #no #cancel)				default: #no.	response = #all 		ifTrue: 			[response := #yes.			overwriteAll := true].	response = #cancel 		ifTrue: 			[response := #no.			cancelExtraction := true].	^response = #yes</body></methods><methods><class-id>Tools.FileTools.ArchiveFile class</class-id> <category>instance creation</category><body>on: aPlatformFilename 	^self new initialize: aPlatformFilename</body></methods><methods><class-id>Tools.FileTools.ArchiveFile class</class-id> <category>utilities</category><body>fileBasename: aPath 	"Get the base name of the file (i.e. the name without the directory portion of it). Use '/' as the path separator."	| pathLen |	pathLen := aPath lastIndexOf: $/.	^pathLen == 0 		ifTrue: [aPath]		ifFalse: [aPath copyFrom: pathLen + 1 to: aPath size]</body></methods><methods><class-id>Tools.FileTools.ZipArchiveFilename</class-id> <category>initialize-release</category><body>initialize: aFilename 	| zipStream |	super initialize: aFilename.	zipStream := Arbor.StreamsAndBytes.UninterpretedReadStream 				openOnFileNamed: aFilename asString.	zipStream beDefaultEndian.	zipDirectory := (Arbor.Zlibrary.ZipCentralDirectory new)				zipFile: aFilename;				loadFrom: zipStream;				yourself</body></methods><methods><class-id>Tools.FileTools.ZipArchiveFilename</class-id> <category>contents</category><body>containedFiles	"Construct a List containing information on every file stored within the archive. The List contains an instance of ArchiveContainedFile for every file in the archive."	^self fileEntries collect: 			[:dirEntry | 			(ArchiveContainedFile new)				filename: (self class getFilenameFromPath: dirEntry filename);				rawDate: (Timestamp fromDate: dirEntry fileDate andTime: dirEntry fileTime);				uncompressedSize: dirEntry uncompressedSize;				ratio: (self class computeRatio: dirEntry compressedSize							and: dirEntry uncompressedSize);				compressedSize: dirEntry compressedSize;				path: (self class getDirectoryFromPath: dirEntry filename)]</body><body>contentsInformation	"Construct a TwoDList containing information on every file stored within the archive.	The list has a row for each file and the following columns: Filename, modification date/time, original size, compression ratio, compressed size, and path within the archive."	"OBSOLETE!"	| flatList |	flatList := self fileEntries inject: #()				into: 					[:list :dirEntry | 					list , (OrderedCollection 								with: (self class getFilenameFromPath: dirEntry filename)								with: dirEntry fileDate shortPrintString , ' ' 										, dirEntry fileTime shortPrintString								with: dirEntry uncompressedSize								with: (self class computeRatio: dirEntry compressedSize										and: dirEntry uncompressedSize)) 						, (OrderedCollection with: dirEntry compressedSize								with: (self class getDirectoryFromPath: dirEntry filename))].	^TwoDList on: flatList columns: 6</body><body>fileEntries	"Get a collection of ZipDirectoryEntry instances coressponding to file (i.e. NOT directories) stored in the archive"	^zipDirectory zipDirectoryEntries 		reject: [:entry | (self class getFilenameFromPath: entry filename) isNil]</body><body>filenames	"Return a collection of the names of the files stored in the archive."	^self fileEntries collect: [:entry | entry filename]</body></methods><methods><class-id>Tools.FileTools.ZipArchiveFilename</class-id> <category>actions</category><body>extractFile: anIndex toFile: aDestFilename 	"Extract file at the index anIndex (within the containedFiles collection) into the file specified with aDestFilename. That file is overwritten."	| stream |	self class forceDirectoryExists: aDestFilename head.	aDestFilename exists ifTrue: [aDestFilename delete].	stream := (aDestFilename withEncoding: #binary) writeStream.	[(self fileEntries at: anIndex) decompressOn: stream] 		ensure: [stream close]</body><body>inspectFileItem: itemNumber 	"Inspect the file item corresponding to the given number."	(self fileEntries at: itemNumber) inspect</body></methods><methods><class-id>Tools.FileTools.ZipArchiveFilename class</class-id> <category>testing</category><body>isAble: aFilename 	"Is this class able to handle the specified file?"	^self isAble: nil havingHeader: (self getFileHeaderFrom: aFilename)	"Note: nil is given to prevent infinite loop when (missing) isAble: havingHeader: would attempt to call this method again."</body><body>isAble: aFilename havingHeader: header 	"Check the first 4B of the file if they are equal to the zip file header magic."	^header size &gt;= 4 and: 			[(header at: 1) == 16r50 and: 					[(header at: 2) == 16r4B 						and: [(header at: 3) == 16r03 and: [(header at: 4) == 16r04]]]]</body></methods><methods><class-id>Tools.FileTools.ZipArchiveFilename class</class-id> <category>private</category><body>getDirectoryFromPath: aPath 	"Retrieve only the directory part (without the filename) from the given pathname."	^aPath copyFrom: 1 to: (aPath lastIndexOf: $/)</body><body>getFilenameFromPath: aPath 	"Retrieve only the filename part (without the path) from the given pathname. Return nil if the aPath specifies a directory."	| pathLen |	(aPath notEmpty and: [aPath last == $/]) ifTrue: [^nil].	pathLen := aPath lastIndexOf: $/.	^pathLen == 0 		ifTrue: [aPath]		ifFalse: [aPath copyFrom: pathLen + 1 to: aPath size]</body></methods><methods><class-id>UnRARInterface</class-id> <category>structs</category><body>RARHeaderData	&lt;C: struct RARHeaderData {			char ArcName[260];			char FileName[260];			unsigned int Flags, PackSize, UnpSize, HostOS, FileCRC, FileTime, UnpVer, Method, FileAttr;			char * CmtBuf;			unsigned int CmtBufSize, CmtSize, CmtState;		}&gt;</body><body>RARHeaderDataEx	&lt;C: struct RARHeaderDataEx {			char ArcName[1024];			wchar_t ArcNameW[1024];			char FileName[1024];			wchar_t FileNameW[1024];			unsigned int Flags, PackSize, PackSizeHigh, UnpSize, UnpSizeHigh, HostOS, FileCRC, FileTime, UnpVer, Method, FileAttr;			char * CmtBuf;			unsigned int CmtBufSize, CmtSize, CmtState;			unsigned int Reserved[1024];		}&gt;</body><body>RAROpenArchiveData	&lt;C: struct RAROpenArchiveData {			char * ArcName;			unsigned int OpenMode, OpenResult;			char * CmtBuf;			unsigned int CmtBufSize, CmtSize, CmtState;		}&gt;</body><body>RAROpenArchiveDataEx	&lt;C: struct RAROpenArchiveDataEx {			char * ArcName;			wchar_t * ArcNameW;			unsigned int OpenMode, OpenResult;			char * CmtBuf;			unsigned int CmtBufSize, CmtSize, CmtState, Flags;			unsigned int Reserved[32];		}&gt;</body></methods><methods><class-id>UnRARInterface</class-id> <category>defines</category><body>ERAR_BAD_ARCHIVE	&lt;C: #define ERAR_BAD_ARCHIVE 13	&gt;</body><body>ERAR_BAD_DATA	&lt;C: #define ERAR_BAD_DATA 12	&gt;</body><body>ERAR_ECLOSE	&lt;C: #define ERAR_ECLOSE 17	&gt;</body><body>ERAR_ECREATE	&lt;C: #define ERAR_ECREATE 16	&gt;</body><body>ERAR_END_ARCHIVE	&lt;C: #define ERAR_END_ARCHIVE 10	&gt;</body><body>ERAR_EOPEN	&lt;C: #define ERAR_EOPEN 15	&gt;</body><body>ERAR_EREAD	&lt;C: #define ERAR_EREAD 18	&gt;</body><body>ERAR_EWRITE	&lt;C: #define ERAR_EWRITE 19	&gt;</body><body>ERAR_NO_MEMORY	&lt;C: #define ERAR_NO_MEMORY 11	&gt;</body><body>ERAR_SMALL_BUF	&lt;C: #define ERAR_SMALL_BUF 20	&gt;</body><body>ERAR_UNKNOWN	&lt;C: #define ERAR_UNKNOWN 21	&gt;</body><body>ERAR_UNKNOWN_FORMAT	&lt;C: #define ERAR_UNKNOWN_FORMAT 14	&gt;</body><body>PASCAL	&lt;C: #define PASCAL _pascal	&gt;</body><body>RAR_DLL_VERSION	&lt;C: #define RAR_DLL_VERSION 3	&gt;</body><body>RAR_EXTRACT	&lt;C: #define RAR_EXTRACT 2	&gt;</body><body>RAR_OM_EXTRACT	&lt;C: #define RAR_OM_EXTRACT 1	&gt;</body><body>RAR_OM_LIST	&lt;C: #define RAR_OM_LIST 0	&gt;</body><body>RAR_SKIP	&lt;C: #define RAR_SKIP 0	&gt;</body><body>RAR_TEST	&lt;C: #define RAR_TEST 1	&gt;</body><body>RAR_VOL_ASK	&lt;C: #define RAR_VOL_ASK 0	&gt;</body><body>RAR_VOL_NOTIFY	&lt;C: #define RAR_VOL_NOTIFY 1	&gt;</body><body>_UNRAR_DLL_	&lt;C: #define _UNRAR_DLL_ 	&gt;</body><body>__DATE__	&lt;C: #define __DATE__ "May 22, 2003"	&gt;</body><body>__FILE__	&lt;C: #define __FILE__ 	&gt;</body><body>__LINE__	&lt;C: #define __LINE__ 0	&gt;</body><body>__STDC__	&lt;C: #define __STDC__ 1	&gt;</body><body>__TIME__	&lt;C: #define __TIME__ "1:42:43 pm"	&gt;</body></methods><methods><class-id>UnRARInterface</class-id> <category>types</category><body>CALLBACK	&lt;C: typedef void * CALLBACK&gt;</body><body>CHANGEVOLPROC	&lt;C: typedef int ( _pascal * CHANGEVOLPROC)(char * ArcName, int Mode)&gt;</body><body>HANDLE	&lt;C: typedef unsigned int HANDLE&gt;</body><body>LONG	&lt;C: typedef long LONG&gt;</body><body>PROCESSDATAPROC	&lt;C: typedef int ( _pascal * PROCESSDATAPROC)(unsigned char * Addr, int Size)&gt;</body><body>UINT	&lt;C: typedef unsigned int UINT&gt;</body><body>UNRARCALLBACK	&lt;C: typedef void * UNRARCALLBACK&gt;</body><body>wchar_t	&lt;C: typedef void * wchar_t&gt;</body></methods><methods><class-id>UnRARInterface</class-id> <category>enums</category><body>UNRARCALLBACK_MESSAGES	&lt;C: enum UNRARCALLBACK_MESSAGES {			UCM_CHANGEVOLUME, 			UCM_PROCESSDATA, 			UCM_NEEDPASSWORD		}&gt;</body></methods><methods><class-id>Tools.FileTools.GZipArchiveFilename</class-id> <category>initialize-release</category><body>initialize: aFilename 	"Load the archive headers, etc."	"NOTE: This implementation is not exactly according to the gzip specification -- the specs say a gzip file is a series of 'members'. I assume there is exactly one member, with no data before or after it."	| gzipStream |	super initialize: aFilename.	gzipStream := Arbor.StreamsAndBytes.UninterpretedReadStream 				openOnFileNamed: aFilename asString.		[gzipStream beLittleEndian.	gzipStream nextU2 ~= 16r8b1f ifTrue: [self class unsupportedFormatError].	compressionMethod := gzipStream nextU1.	flags := gzipStream nextU1.	time := gzipStream nextU4.	extraFlags := gzipStream nextU1.	operatingSystem := gzipStream nextU1.	(flags bitAnd: 4) = 4 		ifTrue: 			[| xlen |			xlen := gzipStream nextU4.			extraField := gzipStream next: xlen].	origFilename := (flags bitAnd: 8) = 8 				ifTrue: [self class readASCIIZ: gzipStream]				ifFalse: [(Filename splitExtension: aFilename tail) first].	(flags bitAnd: 16) = 16 		ifTrue: [fileComment := self class readASCIIZ: gzipStream].	(flags bitAnd: 2) = 2 ifTrue: [crc16 := gzipStream nextU2].	dataStartOffset := gzipStream position.	compressedSize := gzipStream size - dataStartOffset - 8.	gzipStream position: dataStartOffset + compressedSize.	crc32 := gzipStream nextU4.	uncompressedSize := gzipStream nextU4] 			ensure: [gzipStream close].	(flags bitAnd: 16rE0) ~= 0 ifTrue: [self class unsupportedFormatError]</body></methods><methods><class-id>Tools.FileTools.GZipArchiveFilename</class-id> <category>contents</category><body>containedFiles	"Construct a List containing information on every file stored within the archive. The List contains an instance of ArchiveContainedFile for every file in the archive."	| acf |	acf := ArchiveContainedFile new.	acf		filename: origFilename;		rawDate: ((Timestamp fromSeconds: time) addSeconds: 2209075200);		compressedSize: compressedSize;		path: '';		uncompressedSize: uncompressedSize;		ratio: (self class computeRatio: compressedSize and: uncompressedSize).	^List with: acf</body><body>contentsInformation	"Construct a TwoDList containing information on every file stored within the archive.	The list has a row for each file and the following columns: Filename, modification date/time, original size, compression ratio, compressed size, and path within the archive."	"OBSOLETE!"	^self shouldNotImplement</body><body>filenames	"Return a collection of the names of the files stored in the archive."	^List with: origFilename</body></methods><methods><class-id>Tools.FileTools.GZipArchiveFilename</class-id> <category>actions</category><body>extractFile: anIndex toFile: aDestFilename 	"Extract file at the index anIndex (within the containedFiles collection) into the file specified with aDestFilename. That file is overwritten."	| stream |	self class forceDirectoryExists: aDestFilename head.	aDestFilename exists ifTrue: [aDestFilename delete].	stream := (aDestFilename withEncoding: #binary) writeStream.	[self decompressOn: stream] ensure: [stream close]</body><body>inspectFileItem: itemNumber 	"Inspect the file item corresponding to the given number."	self inspect</body></methods><methods><class-id>Tools.FileTools.GZipArchiveFilename</class-id> <category>private</category><body>decompressOn: aWriteStream 	"Decompress the compressed file onto aWriteStream."	| stream |	compressionMethod ~= 8 ifTrue: [self class unsupportedFormatError].	"Only 'deflate' algorithm is supported"	stream := self getDataStream.	[Arbor.Zlibrary.Zlib new inflate: stream on: aWriteStream] 		ensure: [stream close]</body><body>getDataStream	| lowStream |	lowStream := Arbor.StreamsAndBytes.UninterpretedReadStream 				openOnFileNamed: archiveName asString.	^	[lowStream beLittleEndian.	lowStream nextU2 ~= 16r8b1f ifTrue: [self class unsupportedFormatError].	lowStream position: dataStartOffset.	Arbor.StreamsAndBytes.RestrictedReadStream on: lowStream		readLimit: compressedSize] 			ifCurtailed: [lowStream close]</body></methods><methods><class-id>Tools.FileTools.GZipArchiveFilename class</class-id> <category>testing</category><body>isAble: aFilename 	"Is this class able to handle the specified file?"	^self isAble: nil havingHeader: (self getFileHeaderFrom: aFilename)	"Note: nil is given to prevent infinite loop when (missing) isAble: havingHeader: would attempt to call this method again."</body><body>isAble: aFilename havingHeader: header 	"Is this class able to handle the specified file? header contains the header of the file, which can be used to check the file format."	^(header at: 1) = 16r1f and: [(header at: 2) = 16r8b]</body></methods><methods><class-id>Tools.FileTools.GZipArchiveFilename class</class-id> <category>private</category><body>readASCIIZ: aStream 	"Read a zero-terminated string from an UninterpretedByteStream"	| str |	str := List new.	[true] whileTrue: 			[| char |			char := aStream nextU1.			char = 0 ifTrue: [^String fromIntegerArray: str asArray].			str add: char]</body></methods><methods><class-id>Tools.FileTools.ArchiveFileViewer</class-id> <category>aspects</category><body>getContentsTable	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^getContentsTable isNil		ifTrue:			[getContentsTable :=  SelectionInListSortAware new.			getContentsTable selectionIndexHolder compute:				[:v |				self getSelectedFile value: getContentsTable selection].			getContentsTable]		ifFalse:			[getContentsTable]</body><body>getSelectedFile	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^getSelectedFile isNil		ifTrue:			[getSelectedFile := nil asValue]		ifFalse:			[getSelectedFile]</body></methods><methods><class-id>Tools.FileTools.ArchiveFileViewer</class-id> <category>updating</category><body>updateFor: aFilename 	"A file has been selected. Update whatever is needed to show it properly."	archiveFile := ArchiveFile on: aFilename.	self updateTable</body><body>updateForNoSelection	"A file has been unselected, but I am still the current viewer.	Update whatever is needed to show nothing properly."	archiveFile := nil.	self updateTable</body></methods><methods><class-id>Tools.FileTools.ArchiveFileViewer</class-id> <category>private</category><body>executeExtractDialog	"Execute the 'Extract' dialog, return its instance after its execution."	^(ArchiveExtractDialog new)		escapeIsCancel: true;		someFileSelected: self getContentsTable selectionIndex ~= 0;		open;		yourself</body><body>selectedFile	"Get the currently selected filename (with full path). Return nil if nothing is selected."	| selection |	selection := self getContentsTable selectionIndex.	^selection = 0 		ifTrue: [nil]		ifFalse: 			[(self getContentsTable list at: selection) path 				, (self getContentsTable list at: selection) filename]</body><body>updateTable	"Something has changed somewhere, update the table"	Cursor wait showWhile: 			[getContentsTable list: (archiveFile isNil 						ifTrue: [List new]						ifFalse: [archiveFile containedFiles])]</body></methods><methods><class-id>Tools.FileTools.ArchiveFileViewer</class-id> <category>actions</category><body>copyFilename	"Copy the selected filename"	| selection |	selection := self getContentsTable selectionIndex.	selection = Point zero 		ifFalse: 			[ParagraphEditor currentSelection: self getSelectedFile value filename]</body><body>extract	"User has selected 'Extract' from the context menu"	| dlg selectionType destDir |	dlg := self executeExtractDialog.	dlg accept value ifFalse: [^self].	destDir := dlg extractDestDir value.	destDir ifNil: [destDir := ''].	destDir := destDir asString.	destDir isEmpty 		ifTrue: [destDir := archiveFile asFilename asFilename head].	destDir := destDir asFilename asString , (String with: Filename separator).	selectionType := dlg whichFiles asValue value.	selectionType = #onlySelected 		ifTrue: 			[archiveFile 				extractFile: self selectedFile				to: destDir				overwritingExisting: dlg boxOverwriteExisting value				skippingOlder: dlg boxSkipOlderFiles value				usingFolderNames: dlg boxUseFolderNames value].	selectionType = #allFiles 		ifTrue: 			[archiveFile 				extractAllFilesTo: destDir				overwritingExisting: dlg boxOverwriteExisting value				skippingOlder: dlg boxSkipOlderFiles value				usingFolderNames: dlg boxUseFolderNames value].	selectionType = #filesSpecified 		ifTrue: 			[archiveFile 				extractFilesMatching: dlg filesSpecification value				to: destDir				overwritingExisting: dlg boxOverwriteExisting value				skippingOlder: dlg boxSkipOlderFiles value				usingFolderNames: dlg boxUseFolderNames value]</body><body>getSelectedFileCompressedSizePrintStringLabelPressed	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."	"!! HAND EDITED -- compressed size is sorted as number, not as string"	| ascSortBlock dscSortBlock sortBlock |	ascSortBlock := [:x :y | x compressedSize &lt;= y compressedSize].	dscSortBlock := [:x :y | x compressedSize &gt;= y compressedSize].	sortBlock := self getContentsTable sortAspect 				== #getSelectedFileCompressedSizePrintString 					ifTrue: 						[self getContentsTable sortDirection == #asc 							ifTrue: 								[self getContentsTable sortDirection: #dsc.								ascSortBlock]							ifFalse: 								[self getContentsTable sortDirection: #asc.								dscSortBlock]]					ifFalse: 						[self getContentsTable 							sortAspect: #getSelectedFileCompressedSizePrintString.						self getContentsTable sortDirection: #dsc.						ascSortBlock].	self getContentsTable 		list: (SortedCollection withAll: self getContentsTable list				sortBlock: sortBlock) asList</body><body>getSelectedFileDateLabelPressed	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."	"!! HAND EDITED -- date is sorted as date/time, not as string"	| ascSortBlock dscSortBlock sortBlock |	ascSortBlock := [:x :y | x rawDate &lt;= y rawDate].	dscSortBlock := [:x :y | x rawDate &gt;= y rawDate].	sortBlock := self getContentsTable sortAspect == #getSelectedFileDate		ifTrue: [			self getContentsTable sortDirection == #asc				ifTrue: [self getContentsTable sortDirection: #dsc.					ascSortBlock]				ifFalse: [self getContentsTable sortDirection: #asc.					dscSortBlock]]		ifFalse: [self getContentsTable sortAspect: #getSelectedFileDate.				self getContentsTable sortDirection: #dsc.				ascSortBlock].	self getContentsTable list:		(SortedCollection withAll: (self getContentsTable list)			sortBlock: sortBlock) asList.</body><body>getSelectedFileFilenameLabelPressed	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."	| ascSortBlock dscSortBlock sortBlock |	ascSortBlock := [:x :y | x filename printString &lt;= y filename printString].	dscSortBlock := [:x :y | x filename printString &gt;= y filename printString].	sortBlock := self getContentsTable sortAspect == #getSelectedFileFilename		ifTrue: [			self getContentsTable sortDirection == #asc				ifTrue: [self getContentsTable sortDirection: #dsc.					ascSortBlock]				ifFalse: [self getContentsTable sortDirection: #asc.					dscSortBlock]]		ifFalse: [self getContentsTable sortAspect: #getSelectedFileFilename.				self getContentsTable sortDirection: #dsc.				ascSortBlock].	self getContentsTable list:		(SortedCollection withAll: (self getContentsTable list)			sortBlock: sortBlock) asList.</body><body>getSelectedFilePathLabelPressed	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."	| ascSortBlock dscSortBlock sortBlock |	ascSortBlock := [:x :y | x path printString &lt;= y path printString].	dscSortBlock := [:x :y | x path printString &gt;= y path printString].	sortBlock := self getContentsTable sortAspect == #getSelectedFilePath		ifTrue: [			self getContentsTable sortDirection == #asc				ifTrue: [self getContentsTable sortDirection: #dsc.					ascSortBlock]				ifFalse: [self getContentsTable sortDirection: #asc.					dscSortBlock]]		ifFalse: [self getContentsTable sortAspect: #getSelectedFilePath.				self getContentsTable sortDirection: #dsc.				ascSortBlock].	self getContentsTable list:		(SortedCollection withAll: (self getContentsTable list)			sortBlock: sortBlock) asList.</body><body>getSelectedFileRatioLabelPressed	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."	"!! HAND EDITED -- ratio is sorted as number, not as string"	| ascSortBlock dscSortBlock sortBlock |	ascSortBlock := [:x :y | x ratio asNumber &lt;= y ratio asNumber].	dscSortBlock := [:x :y | x ratio asNumber &gt;= y ratio asNumber].	sortBlock := self getContentsTable sortAspect == #getSelectedFileRatio		ifTrue: [			self getContentsTable sortDirection == #asc				ifTrue: [self getContentsTable sortDirection: #dsc.					ascSortBlock]				ifFalse: [self getContentsTable sortDirection: #asc.					dscSortBlock]]		ifFalse: [self getContentsTable sortAspect: #getSelectedFileRatio.				self getContentsTable sortDirection: #dsc.				ascSortBlock].	self getContentsTable list:		(SortedCollection withAll: (self getContentsTable list)			sortBlock: sortBlock) asList.</body><body>getSelectedFileUncompressedSizePrintStringLabelPressed	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."	"!! HAND EDITED -- uncompressed size is sorted as number, not as string"	| ascSortBlock dscSortBlock sortBlock |	ascSortBlock := [:x :y | x uncompressedSize &lt;= y uncompressedSize].	dscSortBlock := [:x :y | x uncompressedSize &gt;= y uncompressedSize].	sortBlock := self getContentsTable sortAspect == #getSelectedFileUncompressedSizePrintString		ifTrue: [			self getContentsTable sortDirection == #asc				ifTrue: [self getContentsTable sortDirection: #dsc.					ascSortBlock]				ifFalse: [self getContentsTable sortDirection: #asc.					dscSortBlock]]		ifFalse: [self getContentsTable sortAspect: #getSelectedFileUncompressedSizePrintString.				self getContentsTable sortDirection: #dsc.				ascSortBlock].	self getContentsTable list:		(SortedCollection withAll: (self getContentsTable list)			sortBlock: sortBlock) asList.</body><body>inspectItem	"Inspect the selected archive item"	| selection |	selection := self getContentsTable selectionIndex.	selection = Point zero ifFalse: [archiveFile inspectFileItem: selection]</body></methods><methods><class-id>Tools.FileTools.ArchiveFileViewer class</class-id> <category>accessing</category><body>isInterestedInFile: aFilename 	^ArchiveFilename isAnyoneAble: aFilename</body><body>tabLabel	^'Archive Contents'</body><body>tabPosition	^10</body></methods><methods><class-id>Tools.FileTools.ArchiveContainedFile</class-id> <category>accessing</category><body>compressedSize	^compressedSize</body><body>compressedSize: anObject	compressedSize := anObject</body><body>date	^date</body><body>date: anObject 	date := anObject.	rawDate := Locale current readTimestampFrom: (ReadStream on: anObject)</body><body>filename	^filename</body><body>filename: anObject	filename := anObject</body><body>path	^path</body><body>path: anObject	path := anObject</body><body>ratio	^ratio</body><body>ratio: anObject	ratio := anObject</body><body>rawDate	^rawDate</body><body>rawDate: anObject 	| zeroesi |	rawDate := anObject.	date := Locale current printAsTime: anObject policyNamed: #short.	zeroesi := date findString: '.000' startingAt: date size - 4.	zeroesi strictlyPositive 		ifTrue: [date := date copyFrom: 1 to: zeroesi - 1]</body><body>uncompressedSize	^uncompressedSize</body><body>uncompressedSize: anObject	uncompressedSize := anObject</body></methods><methods><class-id>Tools.FileTools.ArchiveContainedFile</class-id> <category>printing</category><body>printOn: aStream 	"Append to the argument aStream a sequence of characters that identifies the receiver."	"Amplifies method in superclass to add name string."	super printOn: aStream.	aStream nextPut: $(.	aStream print: filename.	aStream nextPut: $)</body></methods><methods><class-id>Tools.FileTools.RarArchiveContainedFile</class-id> <category>initialize-release</category><body>initializeFrom: aBlockHeader and: aBlockData 	| dataStream |	dataStream := Arbor.StreamsAndBytes.UninterpretedReadStream 				on: (ReadStream on: aBlockData)				endianness: #little.		[| fTime fnameSize parts |	dataStream beLittleEndian.	compressedSize := aBlockHeader at: 5.	uncompressedSize := dataStream nextU4.	operatingSystem := dataStream nextU1.	fileCRC := dataStream nextU4.	fTime := dataStream nextU4.	unpackVersion := dataStream nextU1.	packingMethod := dataStream nextU1.	fnameSize := dataStream nextU2.	fileAttr := dataStream nextU4.	parts := self class 				splitToPathAndName: (dataStream next: fnameSize) asString.	path := parts first.	filename := parts second.	self rawDate: (self class dosTimeToTimeStamp: fTime).	ratio := ArchiveFilename computeRatio: compressedSize and: uncompressedSize] 			ensure: [dataStream close]</body></methods><methods><class-id>Tools.FileTools.RarArchiveContainedFile class</class-id> <category>instance creation</category><body>from: aBlockHeader and: aBlockData 	"Create and initialize the instance with the data in the block header and block data (file header+comment)"	^self new initializeFrom: aBlockHeader and: aBlockData</body></methods><methods><class-id>Tools.FileTools.RarArchiveContainedFile class</class-id> <category>private</category><body>dosTimeToTimeStamp: aDOSTime 	"Convert DOS date/time to TimeStamp"	| year month day hour minute second |	second := (aDOSTime bitAnd: 16r001F) * 2.	minute := (aDOSTime bitAnd: 16r07E0) bitShift: -5.	hour := (aDOSTime bitAnd: 16rF800) bitShift: -11.	day := (aDOSTime bitAnd: 16r001F0000) bitShift: -16.	month := (aDOSTime bitAnd: 16r01E00000) bitShift: -21.	year := (((aDOSTime bitAnd: 16rFE000000) bitShift: -25) bitAnd: 16r7F) 				+ 1980.	^Timestamp fromDate: (Date 				newDay: day				monthNumber: month				year: year)		andTime: (Time new 				hours: hour				minutes: minute				seconds: second)</body><body>splitToPathAndName: aString 	| lastsep |	lastsep := aString lastIndexOf: $\.	^lastsep isZero 		ifTrue: [Array with: '' with: aString]		ifFalse: 			[Array with: (aString copyFrom: 1 to: lastsep)				with: (aString copyFrom: lastsep + 1 to: aString size)]</body></methods><methods><class-id>Tools.FileTools.RarArchiveFilename</class-id> <category>initialize-release</category><body>initialize: aFilename 	"Load the archive headers, etc."	| rarStream |	super initialize: aFilename.	rarStream := Arbor.StreamsAndBytes.UninterpretedReadStream 				openOnFileNamed: aFilename asString.	containedFiles := List new.		[| block |	rarStream beLittleEndian.	block := self class readBlockFrom: rarStream.	(block first ~= 16r6152 or: 			[block second ~= 16r72 or: [block third ~= 16r1a21 or: [block fourth ~= 7]]]) 		ifTrue: [self class unsupportedFormatError].	block := self class readBlockFrom: rarStream.	block second ~= 16r73 ifTrue: [self class unsupportedFormatError].	archiveFlags := block third.	archiveHeaderSize := block fourth.	archiveComment := (archiveFlags bitAnd: 16r02) = 0 				ifFalse: [(block at: 6) asString].	[rarStream atEnd] whileFalse: 			[block := self class readBlockHeaderFrom: rarStream.			block second = 16r74 				ifTrue: 					["File header"					| hdata |					hdata := rarStream next: block fourth - 7.					rarStream skip: (block at: 5) - 4.					containedFiles add: (RarArchiveContainedFile from: block and: hdata)]				ifFalse: 					["Other block type -- skip"					rarStream skip: (block at: 4) + (block at: 5) - 7]]] 			ensure: [rarStream close]</body></methods><methods><class-id>Tools.FileTools.RarArchiveFilename</class-id> <category>contents</category><body>containedFiles	"Return a List containing information on every file stored within the archive. The List contains an instance of ArchiveContainedFile for every file in the archive."	^containedFiles</body><body>contentsInformation	"Construct a TwoDList containing information on every file stored within the archive.	The list has a row for each file and the following columns: Filename, modification date/time, original size, compression ratio, compressed size, and path within the archive."	"OBSOLETE!"	^self shouldNotImplement</body><body>filenames	"Return a collection of the names of the files stored in the archive."	^containedFiles collect: [:containedFile | containedFile filename]</body></methods><methods><class-id>Tools.FileTools.RarArchiveFilename</class-id> <category>actions</category><body>extractFile: anIndex toFile: aDestFilename 	"Extract file at the index anIndex (within the containedFiles collection) into the file specified with aDestFilename. That file is overwritten."	| intrf arcName |	intrf := UnRARInterface new.	arcName := archiveName copyToHeap.		[| openData hArchive |	openData := intrf RAROpenArchiveData gcMalloc.	openData		memberAt: #ArcName put: arcName;		memberAt: #OpenMode put: intrf RAR_OM_EXTRACT;		memberAt: #CmtBuf put: 0;		memberAt: #CmtBufSize put: 0.	hArchive := intrf RAROpenArchive: openData.	hArchive isZero 		ifTrue: 			[self error: #errUnableToOpenArchive &lt;&lt; #dialogs 						&gt;&gt; 'Attempt to open the file using the UnRAR library failed.'].		[| hd name |	hd := intrf RARHeaderData gcMalloc.	hd memberAt: #CmtBuf put: 0.	"Skip i-1 files"	anIndex - 1 timesRepeat: 			[intrf RARReadHeader: hArchive with: hd.			intrf 				RARProcessFile: hArchive				with: intrf RAR_SKIP				with: 0				with: 0].	"Extract the required file"	intrf RARReadHeader: hArchive with: hd.	name := aDestFilename asString copyToHeap.		[intrf 		RARProcessFile: hArchive		with: intrf RAR_EXTRACT		with: 0		with: name] 			ensure: [name free]] 			ensure: [intrf RARCloseArchive: hArchive]] 			ensure: [arcName free]</body></methods><methods><class-id>Tools.FileTools.RarArchiveFilename class</class-id> <category>private</category><body>readBlockFrom: rarStream 	"Returns #( BlockCRC BlockType BlockFlags BlockSize AddedSize #( ...block contents... ) )"	| blockCRC blockType blockFlags blockSize addedSize data |	blockCRC := rarStream nextU2.	blockType := rarStream nextU1.	blockFlags := rarStream nextU2.	blockSize := rarStream nextU2.	addedSize := (blockFlags bitAnd: 16r8000) isZero 				ifTrue: [0]				ifFalse: [rarStream nextU4].	data := rarStream next: blockSize + addedSize - 7.	^(Array 		with: blockCRC		with: blockType		with: blockFlags) , (Array 					with: blockSize					with: addedSize					with: data)</body><body>readBlockHeaderFrom: rarStream 	"Returns #( BlockCRC BlockType BlockFlags BlockSize AddedSize )"	| blockCRC blockType blockFlags blockSize addedSize |	blockCRC := rarStream nextU2.	blockType := rarStream nextU1.	blockFlags := rarStream nextU2.	blockSize := rarStream nextU2.	addedSize := (blockFlags bitAnd: 16r8000) isZero 				ifTrue: [0]				ifFalse: [rarStream nextU4].	^(Array 		with: blockCRC		with: blockType		with: blockFlags) , (Array with: blockSize with: addedSize)</body></methods><methods><class-id>Tools.FileTools.RarArchiveFilename class</class-id> <category>testing</category><body>isAble: aFilename 	"Is this class able to handle the specified file?"	^self isAble: nil havingHeader: (self getFileHeaderFrom: aFilename)	"Note: nil is given to prevent infinite loop when (missing) isAble: havingHeader: would attempt to call this method again."</body><body>isAble: aFilename havingHeader: header 	"Is this class able to handle the specified file? header contains the header of the file, which can be used to check the file format."	^(header at: 1) = 16r52 and: 			[(header at: 2) = 16r61 and: 					[(header at: 3) = 16r72 and: 							[(header at: 4) = 16r21 and: 									[(header at: 5) = 16r1a 										and: [(header at: 6) = 16r07 and: [(header at: 7) = 16r00]]]]]]</body></methods><methods><class-id>Tools.FileTools.ArchiveExtractDialog class</class-id> <category>interface specs</category><body>windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Extract' 			#bounds: #(#{Graphics.Rectangle} 512 384 958 629 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 8 0 ) 					#name: #lblExtractTo 					#label: 'Extract to:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 8 24 162 49 ) 					#name: #editExtractTo 					#model: #extractDestDir ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 8 56 184 160 ) 					#name: #grpFiles 					#label: 'Files' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 16 80 ) 					#name: #radOnlySelected 					#flags: 32 					#model: #whichFiles 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #radFilesSpecifiedChanged ) 					#label: 'Selected file' 					#select: #onlySelected ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 16 104 ) 					#name: #radAllFiles 					#model: #whichFiles 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #radFilesSpecifiedChanged ) 					#label: 'All files' 					#select: #allFiles ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 16 128 ) 					#name: #radFilesSpecified 					#model: #whichFiles 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #radFilesSpecifiedChanged ) 					#label: 'Files:' 					#select: #filesSpecified ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 72 128 172 151 ) 					#name: #editFilesSpec 					#flags: 40 					#model: #filesSpecification ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 16 168 ) 					#name: #boxOverwriteFiles 					#model: #boxOverwriteExisting 					#label: 'Overwrite existing files' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 16 192 ) 					#name: #boxSkipOlderFiles 					#model: #boxSkipOlderFiles 					#label: 'Skip older files' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 16 216 ) 					#name: #boxUseFolderNames 					#model: #boxUseFolderNames 					#label: 'Use folder names' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 360 8 440 32 ) 					#name: #btnExtract 					#model: #accept 					#label: 'Extract' 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 360 40 441 63 ) 					#name: #btnCancel 					#model: #cancel 					#label: 'Cancel' 					#isDefault: false 					#defaultable: true ) 				#(#{UI.TreeViewSpec} 					#layout: #(#{Graphics.Rectangle} 189 23 354 239 ) 					#name: #DirectoryTreeView 					#flags: 15 					#model: #directoryTree 					#useModifierKeys: true 					#selectionType: #highlight 					#rootExpander: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 188 0 ) 					#name: #lblFoldersDrives 					#label: 'Folders/drives:' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 166 24 186 49 ) 					#name: #btnSetFolder 					#model: #setFolderFromEdit 					#label: '-&gt;' 					#style: #default 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.FileTools.ArchiveFilename class</class-id> <category>resources</category><body>genericArchiveIcon	"UIMaskEditor new openOnClass: self andSelector: #genericArchiveIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 18@18 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 3) at: 1 put: Graphics.ColorValue yellow; at: 2 put: Graphics.ColorValue white; at: 3 put: (Graphics.ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 4111); yourself)) usingBits: #[85 85 85 85 80 0 0 0 85 85 85 85 80 0 0 0 85 106 170 170 144 0 0 0 85 128 8 2 144 0 0 0 86 170 170 168 144 0 0 0 88 0 128 40 144 0 0 0 96 2 0 136 144 0 0 0 106 170 170 10 144 0 0 0 96 8 2 8 144 0 0 0 96 8 2 40 144 0 0 0 96 8 2 136 144 0 0 0 106 170 170 10 80 0 0 0 96 8 2 9 80 0 0 0 96 8 2 37 80 0 0 0 96 8 2 149 80 0 0 0 106 170 170 85 80 0 0 0 85 85 85 85 80 0 0 0 85 85 85 85 80 0 0 0])</body></methods><methods><class-id>Tools.FileTools.ArchiveFileViewer class</class-id> <category>interface specs</category><body>windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Archive File Contents' 			#bounds: #(#{Graphics.Rectangle} 465 384 1024 711 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.DataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #showHorizontalLines true #allowColumnResizing true #showVerticalLines true #allowColumnReordering false #allowSorting true ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #contentsDataset 					#model: #getContentsTable 					#menu: #contentsMenu 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true ) 							#model: #'getSelectedFile filename' 							#label: 'Name' 							#labelIsImage: false 							#width: 150 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true ) 							#model: #'getSelectedFile date' 							#label: 'Modified' 							#labelIsImage: false 							#width: 130 							#rendererType: #Text 							#editorType: #None 							#alignment: #right 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true ) 							#model: #'getSelectedFile uncompressedSize printString' 							#label: 'Size' 							#labelIsImage: false 							#width: 60 							#rendererType: #Text 							#editorType: #None 							#alignment: #right 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true ) 							#model: #'getSelectedFile ratio' 							#label: 'Ratio' 							#labelIsImage: false 							#width: 50 							#rendererType: #Text 							#editorType: #None 							#alignment: #right 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true ) 							#model: #'getSelectedFile compressedSize printString' 							#label: 'Packed' 							#labelIsImage: false 							#width: 60 							#rendererType: #Text 							#editorType: #None 							#alignment: #right 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true ) 							#model: #'getSelectedFile path' 							#label: 'Path' 							#labelIsImage: false 							#width: 150 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) ) 					#verticalPolicy: #noWrap 					#labelsAsButtons: true ) ) ) )</body></methods><methods><class-id>Tools.FileTools.ArchiveFileViewer class</class-id> <category>resources</category><body>contentsMenu	"MenuEditor new openOnClass: self andSelector: #contentsMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #E 					#defaultString: 'Extract...' ) 				#value: #extract ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #C 					#defaultString: 'Copy filename' ) 				#value: #copyFilename ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #I 					#defaultString: 'Inspect item' ) 				#value: #inspectItem ) ) #(1 2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>UnRARInterface</class-id> <category>procedures</category><body>RARCloseArchive: hArcData	&lt;C: int _pascal  RARCloseArchive(HANDLE hArcData)&gt;	^self externalAccessFailedWith: _errorCode</body><body>RARGetDllVersion	&lt;C: int _pascal  RARGetDllVersion(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body>RARGetDllVersion: argArray	&lt;C: int __stdcall  RARGetDllVersion(...)&gt;	^self externalAccessFailedWith: _errorCode</body><body>RAROpenArchive: ArchiveData	&lt;C: HANDLE _pascal  RAROpenArchive(struct RAROpenArchiveData * ArchiveData)&gt;	^self externalAccessFailedWith: _errorCode</body><body>RAROpenArchiveEx: ArchiveData	&lt;C: HANDLE _pascal  RAROpenArchiveEx(struct RAROpenArchiveDataEx * ArchiveData)&gt;	^self externalAccessFailedWith: _errorCode</body><body>RARProcessFile: hArcData with: Operation with: DestPath with: DestName	&lt;C: int _pascal  RARProcessFile(HANDLE hArcData, int Operation, char * DestPath, char * DestName)&gt;	^self externalAccessFailedWith: _errorCode</body><body>RARReadHeader: hArcData with: HeaderData	&lt;C: int _pascal  RARReadHeader(HANDLE hArcData, struct RARHeaderData * HeaderData)&gt;	^self externalAccessFailedWith: _errorCode</body><body>RARReadHeaderEx: hArcData with: HeaderData	&lt;C: int _pascal  RARReadHeaderEx(HANDLE hArcData, struct RARHeaderDataEx * HeaderData)&gt;	^self externalAccessFailedWith: _errorCode</body><body>RARSetCallback: hArcData with: Callback with: UserData	&lt;C: void _pascal  RARSetCallback(HANDLE hArcData, UNRARCALLBACK Callback, LONG UserData)&gt;	^self externalAccessFailedWith: _errorCode</body><body>RARSetChangeVolProc: hArcData with: ChangeVolProc	&lt;C: void _pascal  RARSetChangeVolProc(HANDLE hArcData, CHANGEVOLPROC ChangeVolProc)&gt;	^self externalAccessFailedWith: _errorCode</body><body>RARSetPassword: hArcData with: Password	&lt;C: void _pascal  RARSetPassword(HANDLE hArcData, char * Password)&gt;	^self externalAccessFailedWith: _errorCode</body><body>RARSetProcessDataProc: hArcData with: ProcessDataProc	&lt;C: void _pascal  RARSetProcessDataProc(HANDLE hArcData, PROCESSDATAPROC ProcessDataProc)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category></class><class><name>FileViewer</name><environment>Tools.FileTools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>browser </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category></class><class><name>DirectoryItem</name><environment>Tools.FileTools</environment><super>Tools.FileTools.AbstractFileItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cachedSubdirectoryItems </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category></class></st-source>